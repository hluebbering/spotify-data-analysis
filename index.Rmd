---
title: |
  ![](assets/static/R2.svg){width="100%"} 
  
subtitle: "Spotify Analysis" 
date: |
  <div class="spotify1">
  <h4>DATA 557 | Winter 2022 </h4>
  <h5>Group Members </h5>
  - Aniket Fadia
  - Hannah Luebbering
  - Rebecca Klein
  - Teju Kandula
  </div>
output:
  html_document: 
    css: assets/main.css
    toc: no
    toc_float: no
# knit: pagedown::chrome_print
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "docs") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(Rmisc)
library(plotrix)
library(gridExtra)
library(ggridges)
library(dplyr)
library(kableExtra)
library(reactable)
library(htmltools)
library(reactablefmtr)
library(ggplot2)
library(hrbrthemes)
library(ggcorrplot)

df <- readRDS(file = "assets/data/spotify_data.rds")
source("spotifyTable.R")
source("top50Playlist.R")

```



---------------------------------------------------




## Introduction


### Data Description:

All of the data sourced for this project is from the **Spotify API**. There are two main sub categories of data from the Spotify API that we use: the Daily Top 200 Charts and Spotify Track Features.


> 1. Daily Top 200 Charts <div class = "track__plays">(Spotify API)</div>


The **Daily Top 200 Charts** shows the top $200$ most streamed tracks each day from January 1, 2018 to December 31, 2021. For example, Spotify Daily Top Songs USA shows the daily update of the most played tracks across the US right now. The variables included in this dataset are `rank`, `uri`, `artist_names`, `track_name`, `source`, `peak_rank`, `previous_rank`, `days_on_chart`, `streams`.


```{r}
df.daily <- read.csv("assets/data/us-daily-2022-02-23.csv")
colnames(df.daily) <- c("rank", "uri", "artists", "track", "source", "peak", "previous", "streak", "streams")
df.daily$difference <- (df.daily$rank - df.daily$previous)
df.daily <- df.daily %>% 
  select(rank, difference, track, artists, streams) %>% 
  mutate(rank_icons = case_when(difference < 0 ~ "arrow-down",
                                difference > 0 ~ "arrow-up",
                                difference == 0 ~ "minus", TRUE ~ "other")) %>%
  mutate(rank_colors = case_when(difference < 0 ~ "#e91e34",
                                 difference > 0 ~ "#1db954",
                                 difference == 0 ~ "#cbcacf", TRUE ~ "other"))


reactable(
  df.daily %>% head(6),
  columns = list(
    rank = colDef(
      header = tagList(
          span("#", "aria-hidden" = "true", title = " "),
          span(" ", class = "sr-only")),
      width = 40,
      class = "number"),
    difference = colDef(
      name = " ",
      width = 30,
      cell = icon_sets(df.daily, icon_color_ref = "rank_colors", icon_ref = "rank_icons", 
                       icon_position = "over", icon_size = 10, colors = "black")),
    track = colDef(
      cell = function(value, index) { 
        artists <- df.daily$artists[index] # Show artists under track names
        artists <- if (!is.na(artists)) artists else "Unknown"
        div(div(style = list(fontWeight = 600), value),
            div(style = list(fontSize = 12, color = "#aaaaaa"), artists))}),
    artists = colDef(show = FALSE),
    streams = colDef(
      name = "Streams",
      format = colFormat(separators = TRUE),
      width = 120,
      class = "number"),
    rank_icons = colDef(show = FALSE),
    rank_colors = colDef(show = FALSE)
  ),
  highlight = TRUE,
  wrap = FALSE,
  paginationType = "simple",
  minRows = 6,
  theme = spotify_theme2()
)
```




\ 


> 2. Spotify Track Features <div class = "track__plays">(Spotify API)</div>

The **Spotify Track Features** dataset shows audio features for each track streamed. A full list of these, along with their verbal definitions, can be found on Spotify’s page for developers. There are 12 audio features for each track, including confidence measures `acousticness`, `instrumentalness`, `liveness`, `speechiness`; perceptual measures `danceability`, `energy`, `loudness`, `valence`; and descriptors `key`, `duration`, `mode`, `tempo`.


```{r}
trackFeatures <- trackFeatures %>% head(4) %>% 
  rename(c(track = track.name, duration = duration_ms))

reactable(
  trackFeatures,
  columns = list(
    position = colDef(
      header = tagList(
          span("#", "aria-hidden" = "true", title = " "),
          span(" ", class = "sr-only")),
      width = 32,
      class = "number"),
    track = colDef(
      width = 120,
      cell = function(value, index) {
        div(div(style = list(fontWeight = 600), value))}),
    danceability = colDef(width = 86, class = "number"),
    energy = colDef(width = 70, class = "number"),
    key = colDef(width = 40, class = "number"),
    loudness = colDef(width = 70, class = "number"),
    mode = colDef(width = 50, class = "number"),
    speechiness = colDef(width = 75, class = "number"),
    acousticness = colDef(width = 75, class = "number"),
    instrumentalness = colDef(width = 80, class = "number"),
    liveness = colDef(width = 60, class = "number"),
    valence = colDef(width = 80, class = "number"),
    tempo = colDef(width = 60, class = "number"),
    duration = colDef(width = 80, class = "number")
  ),
  highlight = TRUE,
  wrap = FALSE,
  paginationType = "simple",
  resizable = TRUE,
  theme = spotify_theme3()
)

```



\ 

#### Final Data

We merged the two data sources into a single data frame with the combination of being the unique identifier of an observation.


```{r, out.width="100%"}
df.description  %>% 
  kable(escape = F) %>%
  kable_styling(bootstrap_options = c("hover", "striped"), full_width = F, html_font = "Roboto", font_size = 12.5) %>%
  row_spec(0:22, hline_after = F, extra_css = "border-bottom: 1px solid #FEFEFE;") %>%
  column_spec(1, color = "#111111", extra_css = "font-weight: 400;") %>%
  column_spec(2:3, color = "#555", extra_css = "font-weight: 300;") %>%
  row_spec(0, color = "#111111", extra_css = "text-transform: uppercase; letter-spacing: 1.25px; font-weight: 400; font-size: 11.5px")
```



We do not have a genre for each song. So, we are utilizing the genres the artist belongs to and using those genres for each song. We want to discuss this with you in the meeting which we will be scheduling this week.




-----------------------------------------



### Questions/Hypotheses:

<div class="spotify2">
<ol class="roundedlist">

1. Does time period change the popularity (proportion of streams) of pop, rap, hip hop, r&b, and rock genres in the Spotify US daily charts?
    a. Does whether or not it is a weekday change the popularity (proportion of songs in the top 200 list) of pop, rap, hip hop, r&b, and rock genres in the Spotify US daily charts?
    b. Does whether or not it is during the holiday season change the popularity (proportion of songs in the top 200 list) of pop, rap, hip hop, r&b, and rock genres in the Spotify US daily charts?
    c. Does what meteorological season it is change the popularity (proportion of songs in the top 200 list) of pop, rap, hip hop, r&b, and rock genres in the Spotify US daily charts?
2. Did the popularity of happy songs (mean valence) in the top 200 Spotify US daily streams change during Covid?
3. What parameters are the most important in predicting the popularity on Spotify in the US?

</ol>
</div>


-----------------------------------


## Analysis:

### Question 1. 


> 1. Does time period change the popularity of genres in the Spotify US daily charts? <div class = "track__plays">(Question 1)</div>

<div class="methods">


This question explores the proportion of songs of certain genres (pop, rap, hip hop, r&b, and rock) within a certain time-based constraint (weekday vs weekend, the holiday season or not, meteorological season). As the chart above demonstrates, time plays an important part in what genres people listen to. For example, pop has a very strong seasonality component. People have also been listening to more rock, but less r&b. We want to look at smaller periods of time and see what effect they may have on the proportion of genres in Spotify’s Top 200 charts.

```{r}
dfQ1 <- df[df$genre == c('pop', 'rock', 'rap', 'hip hop', 'r&b'), ] %>% 
  group_by(Date,genre) %>%
  summarise(n = n()) %>%
  mutate(Freq = n/sum(n))

dfQ1$Date <- as.Date(dfQ1$Date)

pQ1 <- ggplot(data = dfQ1, mapping = aes(x = Date, y = Freq, group = genre, color = genre)) +
  geom_line(cex = 0.425) +
  ggtitle("Proportions of Popular Genres Over Time") +
  scale_color_manual(values = c("#4D49BE", "#C8E379","#EEDAEA","#2CC84D", "#E277CD")) +  theme_ipsum(base_size = 11, base_family = "Roboto Condensed") + theme(axis.text.x=element_text(angle=60, hjust=1, size = 8), axis.text.y = element_text(size = 8), plot.title = element_text(size = 10), legend.text = element_text(size = 8), legend.title = element_blank(), legend.position = "bottom") + ylab("Proportion")

pQ1
```




#### Data: 

The variable of interest is the proportion of songs of a certain genre within a certain time-based constraint (weekday vs weekend, the holiday season or not, meteorological season). This is calculated by grouping the data by the time-based constraint, and then calculating the proportion by summing the column for the genre being tested and dividing by the number of rows in that group. This works because summing the column is just counting the number of TRUEs in that column which is equivalent to the number of songs with that genre.

While the actual calculation is done based on rows and ignores the track_id, in actuality, this calculation is equivalent to counting the unique songs of the genre and multiplying it by the number of days it has appeared on Spotify’s Top 200 chart (in the relevant time-period).



#### Part a:


> a. Does whether or not it is a weekday change the popularity (proportion of songs in the top 200 list) of pop, rap, hip hop, r&b, and rock genres in the Spotify US daily charts?


A weekday is considered to be Monday, Tuesday, Wednesday, or Thursday. A weekend is considered to be Friday, Saturday, or Sunday.


##### Statistical Methods


The hypothesis tests were performed for each of the following genres: pop, rap, hip hop, r&b, and rock.

- **Null hypothesis:** The proportion of songs in the Spotify US Top 200 Daily Charts during weekdays of the genre being tested is equal to the proportion of songs during weekends. $H_0\colon p_\mathrm{weekday} = p_\mathrm{weekend}$

- **Alternative hypothesis:** The proportion of songs in the Spotify US Top 200 Daily Charts during weekdays of the genre being tested is NOT equal to the proportion of songs during weekends. $H_1\colon p_\mathrm{weekday} \neq p_\mathrm{weekend}$


We want to compare the proportion of songs for each genre on weekdays vs weekends. The two samples (weekday and weekend) are independent with independent observations, and the sample sizes $n_\mathrm{weekday}$ and $n_\mathrm{weekend}$ are both large. 

Under these assumptions, we can use the two-sided two-sample large sample Z-test to compare the proportions for each genre on weekdays vs the weekend. Because the test will be performed on 5 genres, a Bonferroni correction will be applied to the significance level by dividing 0.05 by 5 (the number of genres), resulting in a significance level of  = 0.01.

The Z-value is calculated using a pooled sample proportion in the following equation: 

$$
\begin{align}
Z = \frac{\hat{p}_A - \hat{p}_B}{\sqrt{\hat{p} \left(1- \hat{p} \right) \left(1/n_A + 1/n_B \right)}}, && 
\hat{p} = \frac{n_A \, \hat{p}_A + n_B \, \hat{p}_B}{n_A + n_B}
\end{align}
$$



##### Results 

Based on the p-values produced using a significance level of 0.01, we have evidence to reject the null hypotheses that the proportion of songs by genre is the same on weekdays and the weekend for all the genres tested (pop, rap, hip hop, r&b, and rock). 

Looking at the bar chart, however, it is difficult to visually see much difference in the proportions for any genre. This demonstrates that although there is a statistically significant difference, the difference itself is not particularly strong. Interestingly, pop and r&b songs have a higher proportion during the week, whereas rap, hip hop, and rock have a higher proportion during the weekend.



--------------------------------



#### Part b:



> b. Does whether or not it is during the holiday season change the popularity (proportion of songs in the top 200 list) of pop, rap, hip hop, r&b, and rock genres in the Spotify US daily charts?

The holiday season is considered to be the day after. Thanksgiving through December 31st. 


##### Statistical Methods

The hypothesis tests were performed for each of the following genres: pop, rap, hip hop, r&b, and rock.

- **Null hypothesis:** The proportion of songs in the Spotify US Top 200 Daily Charts during the holiday season of the genre being tested is equal to the proportion of songs during the rest of the year. $H_0 \colon p_\mathrm{holiday} = p_\mathrm{not \, holiday}$

- **Alternative hypothesis:** The proportion of songs in the Spotify US Top 200 Daily Charts during the holiday season of the genre being tested is NOT equal to the proportion of songs during the rest of the year. $H_1 \colon p_\mathrm{holiday} \neq p_\mathrm{not \, holiday}$


We want to compare the proportion of songs for each genre during the holiday season and otherwise. The two samples (holiday and not_holiday) are independent with independent observations, and the sample sizes $n_\mathrm{holiday}$ and $n_\mathrm{not \, holiday}$ are both large. 

Under these assumptions, we can use the two-sided two-sample large sample Z-test to compare the proportions for each genre during the holiday season and otherwise. Because the test will be performed on 5 genres, a Bonferroni correction will be applied to the significance level by dividing 0.05 by 5 (the number of genres), resulting in a significance level of $\alpha = 0.01$.

The Z-value is calculated using a pooled sample proportion in the following equation: 


$$
\begin{align}
Z = \frac{\hat{p}_A - \hat{p}_B}{\sqrt{\hat{p} \left(1- \hat{p} \right) \left(1/n_A + 1/n_B \right)}}, && 
\hat{p} = \frac{n_A \, \hat{p}_A + n_B \, \hat{p}_B}{n_A + n_B}
\end{align}
$$



##### Results


Based on the p-values produced using a significance level of 0.01, we have evidence to reject the null hypotheses that the proportion of songs by genre is the same during the holiday season and otherwise for all the genres tested (pop, rap, hip hop, r&b, and rock). 

This difference is also much more apparent in the bar chart as compared to the bar chart for subquestion A comparing weekday and weekend, meaning the difference is not only statistically significant, but also strong for a majority of the genres tested. Another interesting observation is that of the 5 genres tested, only rock has a higher proportion during the holiday season than outside of it.


--------------------------------


#### Part c:



> c. Does what meteorological season it is change the popularity (proportion of songs in the top 200 list) of pop, rap, hip hop, r&b, and rock genres in the Spotify US daily charts?

Spring is considered to be March, April, and May. Summer is considered to be June, July, and August. Fall is considered to be September, October, and November. Winter is considered to be December, January, and February.


##### Statistical Methods

The hypothesis tests were performed for each of the following genres: pop, rap, hip hop, r&b, and rock

- **Null hypothesis:** There is no difference in the proportion of songs in the Spotify US Top 200 Daily Charts of the genre being tested between the different seasons. $H_0 \colon p_\mathrm{spring} = p_\mathrm{summer} = p_\mathrm{fall} = p_\mathrm{winter}$

**Alternative hypothesis:** There is a difference in the proportion of songs in the Spotify US Top 200 Daily Charts of the genre being tested between at least two of the seasons. $H_1 \colon p_\mathrm{season \, 1} \neq p_\mathrm{season \, 2}$


We want to compare the proportion of songs for each genre during each season. The four samples (spring, summer, fall, winter) are independent with independent observations, and the sample sizes are all large. 

Under these assumptions, we can use the chi-squared test (which is the equivalent to the two-sided two-sample large sample Z-test, except it can handle more than 2 samples) to compare the proportions for each genre during each season. Because the test will be performed on 5 genres, a Bonferroni correction will be applied to the significance level by dividing 0.05 by 5 (the number of genres), resulting in a significance level of  = 0.01.

The p-value was calculated using the chisq.test function with ‘correct’ set to false. The data input into this function looks similar to the following table (without the season column):


##### Results

Based on the p-values produced using a significance level of 0.01, we have evidence to reject the null hypotheses that the proportion of songs by genre is the same regardless of season for all the genres tested (pop, rap, hip hop, r&b, and rock).

Some interesting observations from the bar chart include that rap seems to be much lower in the winter, and summer and spring appear to be the most similar in terms of proportion of genre.


<div class = "discs"></div>


</div>


-----------------------------------


### Question 2.

> 2. Did the popularity of happy songs in the top 200 Spotify charts change during Covid? <div class = "track__plays">(Question 2)</div>


<div class="methods">

#### Calculated Variables:
 
We use the Spotify Daily Top Tracks as described in the Data Description above. Particularly, question 2 makes use of the `track_name`, `valence`, and `Date` columns. Based on these columns, we created a `covid` variable to define whether a track entry was added to the top 200 playlist before Covid (`Date` < "03/13/2020") or after Covid (`Date` >= "03/13/2020"). Tracks added before Covid (03/13/2020) are labeled *before* whereas tracks added after Covid are labeled *after*.


```{r}
df$Date <- as.Date(df$Date) # Convert character to date
df <- df %>%
  mutate(covid = case_when(Date < "2020-03-13" ~ "before",
                           Date >= "2020-03-13" ~ "after")) # Adding column based on other column
```

```{r}
df.valence <- df %>%
  select(Track.Name, valence, Date, covid)
df.valence <- data.frame(df.valence[sample(1:nrow(df.valence)), ], row.names = NULL)
df.valence <- head(df.valence, 10)
colnames(df.valence) <- c("track", "valence", "date", "covid")

kable(df.valence, escape = F) %>%
  kable_styling(bootstrap_options = c("hover", "striped"), full_width = F, html_font = "Roboto", font_size = 12.5) %>%
  row_spec(0:2, hline_after = F, extra_css = "border-bottom: 1px solid #FEFEFE;") %>%
  column_spec(1, color = "#111111", extra_css = "font-weight: 400;") %>%
  column_spec(2:4, color = "#555", extra_css = "font-weight: 300;") %>%
  row_spec(0, color = "#111111", extra_css = "text-transform: uppercase; letter-spacing: 1.25px; font-weight: 400; font-size: 11.5px")

```



#### Statistical Method: 

We want to compare mean valence values before and after Covid. For the data, the two samples (*before* and *after*) are independent with independent observations, and the sample sizes $n_{\mathrm{before}}$ and $n_{\mathrm{after}}$ are both large. Under these assumptions, we can use the **two-sided two-sample large sample Z-test** to compare the mean valences before and after Covid. This means that we compare the Z test statistic to the standard normal distribution.

We test the null hypothesis of no difference between valence means, i.e., we define the null hypothesis as $H_0 : \mu_{\mathrm{before}} = \mu_{\mathrm{after}}$ versus the 2-sided alternative hypothesis $H_1 : \mu_{\mathrm{before}} \neq \mu_{\mathrm{after}}$, where $\mu_{\mathrm{before}}$ and $\mu_{\mathrm{after}}$ are the mean valences per song for songs added before and after Covid, respectively. The test is conducted at a significance level of $\alpha = 0.05$.


#### Results: 

First, we calculate the mean ($\mu_{\mathrm{before}}$, $\mu_{\mathrm{after}}$), standard deviation ($s_{\mathrm{before}}$, $s_{\mathrm{after}}$), and size ($n_{\mathrm{before}}$, $n_{\mathrm{after}}$) for each of the two samples. 

```{r, echo=TRUE}
m = with(df, tapply(valence, covid, mean))
s = with(df, tapply(valence, covid, sd))
n = with(df, tapply(valence, covid, length))
```

```{r}
data.frame(m, s, n) %>% arrange(m) %>% 
  kable(col.names = c("mean", "std dev", "size"), escape = F) %>%
  kable_styling(bootstrap_options = c("hover", "striped"), full_width = F, html_font = "Roboto", font_size = 12.5) %>%
  row_spec(0:2, hline_after = F, extra_css = "border-bottom: 1px solid #FEFEFE;") %>%
  column_spec(1, color = "#111111", extra_css = "font-weight: 400;") %>%
  column_spec(2:4, color = "#555", extra_css = "font-weight: 300;") %>%
  row_spec(0, color = "#111111", extra_css = "text-transform: uppercase; letter-spacing: 1.25px; font-weight: 400; font-size: 11.5px")

```


Using these values, we can then calculate the test statistic:

$$
\begin{align}
Z & = 
\frac{\left|\bar{X}_\mathrm{before} - \bar{X}_\mathrm{after}\right|}{\left. s^2_\mathrm{before} {\bf\large /} n_\mathrm{before}\right. + \left. s^2_\mathrm{after} {\bf\large /} n_\mathrm{after} \right.} = 
\frac{\left|0.4572 - 0.4826 \right|}{\sqrt{0.2015^2 / 1117863 + 0.2273^2/592944}} = 
72.379
\end{align}
$$


Next, we calculate the p-value using the standard normal distribution (since $n_\mathrm{before}$ and $n_\mathrm{after}$ are both large). The p-value is a probability about the test statistic, calculated under the assumption that the null hypothesis is true.

- If the p-value is less than $\alpha$ (i.e., $p \lt 0.05$), then we reject the null hypothesis of equal means.
    - This would mean that the mean valences per song before and after Covid are not equal (i.e., the popularity of happy songs changed during Covid).
- If the p-value is greater than $\alpha$ (i.e., $p \gt 0.05$), then we do not reject the null hypothesis of equal means.
    - This would mean that the mean valences per song before and after Covid are equal (i.e., the popularity of happy songs did not change during Covid).



```{r, echo=TRUE}
z = (m[1] - m[2] - 0) / sqrt(sum(s^2 / n))
p = 2 * (1 - pnorm(z))
```



The p-value for the test is $p \lt 0.001$. Based on the test, we reject the null hypothesis of equal valence means at the $0.05$ level of significance.


We can also calculate the confidence interval for the difference between population means. A confidence interval provides additional information beyond the hypothesis test. In general, we can interpret a confidence interval as the set of all values of the population parameter that would not have been rejected by the corresponding hypothesis test. Hence, we can state the null hypothesis as $H_0: \mu_\mathrm{before} - \mu_\mathrm{after} = 0$ and then check whether the confidence interval contains the value $0$. 


```{r, echo=TRUE}
se = sqrt(s[1]^ 2 / n[1] + s[2]^ 2 / n[2])
z.05 = qnorm(0.975)
lower = m[1] - m[2] - z.05 * se
upper = m[1] - m[2] + z.05 * se
```


The confidence interval for the difference between population means is $(0.0247, 0.0261)$, which is very similar to the result from the large-sample procedure. Hence, since the interval does not contain the value $0$, we would reject the null hypothesis $H_0: \mu_\mathrm{before} - \mu_\mathrm{after} = 0$ and conclude that the mean valences per song before and after Covid are different. 


```{r, fig.width=8, fig.height=4}
dfQ2 <- df %>% 
  group_by(Date) %>%
  summarise(valence.mean = mean(valence))
dfQ2$Date <- as.Date(dfQ2$Date)
dfQ2 <- dfQ2 %>% mutate(cov = ifelse(Date < "2020-03-13", "before", "after"))


pQ2 <- ggplot(data = dfQ2, mapping = aes(x = Date, y = valence.mean, color=cov)) +
  geom_line() +
  ggtitle("Daily Mean Valence Over Time") +
  scale_color_manual(values = c("#C8E379", "#79D97C")) +  theme_ipsum(base_size = 11, base_family = "Roboto Condensed") + theme(axis.text.x=element_text(angle=60, hjust=1, size = 8), axis.text.y = element_text(size = 8), plot.title = element_text(size = 10), legend.text = element_text(size = 8), legend.title = element_blank(), legend.position = "right", axis.title.y = element_blank()) + ylab("Proportion") + geom_vline(xintercept = 2020)

pQ2
```


</div>


-----------------------------------


### Question 3. 


> 3. What parameters are the most important in predicting the popularity on Spotify in the US? <div class = "track__plays">(Question 3)</div>

<div class="methods">


#### Calculated Variables:


For this question we used the Spotify Daily Top Tracks data described in the dataset section. We then aggregated the data by song id, so each song has its own row. Each song has the same values for each attribute so we take the mean of these attributes. These attributes include explicit, acousticness, danceability, duration, energy, instrumentalness, key, liveness, loudness, mode, speechiness, tempo and valence. Then, we created a new variable for popularity and named it updated_rank. To calculate the updated_rank we do 201 - Rank (i.e. rank 1 has score 200, rank 200 has score 1) so a  higher updated_rank means the song is performing better in the ranks. We then sum this updated_rank for each song to get a popularity score. This way the longer the song is in the Spotify top 200 the higher the popularity score. 




#### Statistical Methods


To answer this question we created three linear regression models and looked at the significance of each independent variable in each model. For each independent variable we look at the p-value for the t-test H0: x=0 and Ha: x0 for each variable,x, in the linear regression model. First we started by looking at the correlation matrix. 


```{r}
dfQ3 <- df %>% select(c(acousticness, danceability, energy, duration, instrumentalness, key, liveness, loudness, mode, speechiness, tempo, time_signature, valence))

dfQ3$updated_rank <- 201 - df$Rank

correlation_matrix <- round(cor(dfQ3),1)
corrp.mat <- cor_pmat(dfQ3)

ggcorrplot(correlation_matrix, hc.order =TRUE, outline.color ="white", lab = TRUE, type = "lower", lab_size = 1.75, show.legend = FALSE, show.diag = FALSE) +
   scale_fill_gradient2(limit = c(-0.5,0.7), low = "#41B6E6", high =  "#78D64B", mid = "white", midpoint = 0)+ theme(axis.text.y = element_text(size = 10), axis.text.x = element_text(size = 10))
```




From the above correlation matrix graph we can see that streams and updated_rank are highly correlated. This makes sense since the rank on spotify is based on the number of streams. We will remove this variable when using linear regression as it is used in the formula to predict popularity and thus not an accurate predictor variable. Other than the total number of streams we can see that there is little to no correlation between the other variables and the updated_rank.

We then continue on to make three linear regression models. Each model is described below:

- Model1: Simple additive model using all predictor variables in the correlation matrix above
- Model2: Model created using backwards AIC and all predictor variables in the correlation matrix above as well as all the interaction terms
- Model3: Model created using backwards AIC and all predictor variables in the correlation matrix above as well as all the interaction terms and taking log base 10 of the updated_rank

Below are the coefficient estimates, p-values and diagnostic plots for each model.


Model 1: 
Adjusted R-squared: 0.01226


Model 2:
Adjusted R-squared: 0.01749


Model 3: 
Adjusted R-squared: 0.3083





#### Results


We found that all three models were not great at predicting the popularity of a song. The adjusted R-squared for all three models were very low. Some of the predictor variables were significant, but the coefficients were too small to have a strong impact on updated_rank. 

Another important thing to note is that none of the models meet the assumptions for linear regression. Constant variance does not hold as all the fitted vs. residuals plots are not evenly distributed around x = 0. Linearity does not hold as the mean in the fitted vs. residuals plot does not look close to 0 and normality is violated as the q-q plots do not follow a straight line. All three models are unreliable. 

However, we look at the commonalities between the models to answer our question. In all three models danceability, energy and loudness or an interaction term containing one of these variables are statistically significant. Although the models do not meet the requirements needed for linear regression and they are not very accurate, since all three models show significance for the above variables we will cautiously conclude that danceability, energy and loudness are the most influential factors when modeling the popularity of a song on the spotify top 200. 






</div>




--------------------------------------------



## Discussion




--------------------------------------------



## References





